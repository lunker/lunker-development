# Lambda


- 클래스 없이 함수구현체가 존재할 수 있게됨
- 왼쪽의 (User 01, User 02) 부분은 functional interface(추상 메소드가 하나만 있는 인터페이스)에 선언된 추상메소드의 argument 를 나타낸다.
- 오른쪽 부분은 추상메소드의 구현내용(implementation)을 적어주는데 return type은 interface 의 추상메소드 signature를 따라 자동으로 결정된다. ( Runnable의 경우 void 임 ).
- 추상 인터페이스 메소드의 구현체 내부에서 외부에 있는 변수에 접근이 가능하다. ==> "클로저", "변수포획" 이라고 불린다.  
- **'지울 수 있는건 모두 지우자!',  모든걸 컴파일러의 추론에 의지하고 코드로 표현하는건 다 없애버려서 코드를 간결하게 만드는 것.**  
- '익명 클래스 객체' :: 인터페이스를 구현함에 있어, 해당 인터페이스를 구현한 클래스의 객체를 만들지 않고, 직접 인터페이스의 구현체를 생성하는 방법


[함수형 인터페이스]
- 람다 표현식을 활용하여 인터페이스를 구현한 것.
- 이를 위해서는 구현해야 될 인터페이스에 abstract method가 1개만 있어야한다.
- 함수형 인터페이스는, '추상 메서드가 1개인 인터페이스를 부르는 명칭'
- 하지만, 이후에 함수형 인터페이스에 추가적인 기능 개발을 위해 메서드를 추가 하게 되면, 더이상 함수형 인터페이스가 아니게 된다. 이는 혼란을 야기하므로,
인터페이스가 함수형 인터페이스임을 알려주는 '@FunctionalInterface' annotation이 있다.
- 자바8에서 기본적으로 제공하는 Functional Interface는 다음과 같다.
  - Supplier<T>
  - Consumer<T>
  - Function<T,R>
  - Predicate<T>
  -
- 함수형 인터페이스는 '추상 메서드가 1개인 인터페이스' 이므로, 해당 인터페이스에 있는 Default Method는 영향이 없다. (인터페이스 확장 가능)
-


[행위 파라미터화 (Behavior Parameterize)]
- 매개변수로 데이터를 주로 전달한다.
- 하지만, 매개변수로 데이터가 아닌 행위를 전달하면 조금 더 유연한 코드를 작성할 수 있다.
- Predicate가 그 예시.


[메서드 레퍼런스 (Method Reference)]
- 함수형 인터페이스에서의 구현 부분이 하나의 메서드 호출로 끝나버릴 경우, 이를 축약할 수 있다.







**참고**  
- https://www.slideshare.net/gyumee/java-8-lam bda-35352385
