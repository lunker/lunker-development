# sync-async & block-nonblock

# block/non-block
  - 함수 호출 후, callee function의 결과를 기다리나 안기다리나
  - 호출 되는 함수가 바로 리턴하느냐 마느냐의 관심사
  - non-blocking : 호출된 함수가 바로 리턴해서 호출한 함수에게 제어권을 넘겨주고, 호출한 함수가 다른 일을 할 수 있는 기회를 줄 수 있으면 non-blocking
  - blocking : 그렇지 않고 호출된 함수가 자신의 작업을 모두 마칠 때까지 호출한 함수에게 제어권을 넘겨주지 않고 대기하게 만든다면 Blocking이다.


# sync/async
  - 함수 호출 후 해당 함수의 종료 여부를 신경쓸것인가?
  -> 신경쓴다면 물어보거나 기다리거나
  -> 신경을 누가 쓸 것인가? caller? callee?
  -> callee가 신경쓴다면, caller가 넘겨준 callback을 수행시킨다.
  -> caller가 신경쓴다면, polling 등의 방식으로 완료 여부를 체크한다.


# Async
- 작업을 요청해놓고 다른 일을 하다가 해당 작업이 완료되면, 그때 완료되었음을 '통지'받고 그에 따른 작업을 처리한다. 
- System Call이 반환될 때 실행된 결과(데이터)와 함께 반환되지 않는 경우
- 함수호출의 결과는 Callback을 통해서 받아오고, 처리된다.

호출되는 함수에게 callback을 전달해서, 호출되는 함수의 작업이 완료되면 호출되는 함수가 전달받은 callback을 실행하고, 호출하는 함수는 작업 완료 여부를 신경쓰지 않으면 Asynchronous다.

호출하는 함수가 호출되는 함수의 작업 완료 후 리턴을 기다리거나, 또는 호출되는 함수로부터 바로 리턴 받더라도 작업 완료 여부를 호출하는 함수 스스로 계속 확인하며 신경쓰면 Synchronous다.


# Blocking 
- I/O 작업이 끝날 때 까지, 대기해야한다. 
- 그렇기 때문에 커널이 작업을 완료기 전까지 유저 프로세스는 작업을 중단한 채 대기해야 한다.
- I/O작업은 CPU자원을 거의 쓰지 않기 때문에 CPU 자원 낭비가 심하다. 


# Non-blocking 
- I/O 작업을 진행하는 동안 유저 프로세스의 작업을 중단시키지 않는다. 
- 유저 프로세스가 I/O를 처리하기 위해 System Call을 호출하면, 커널에서는 해당 System Call의 진행 사항과 상관없이 바로 결과를 반환한다. 
  이때 반환되는 결과는 반환되는 순간에 가져올 수 있는 데이터에 해당한다. 즉 완벽하게 원하는 데이터가 아니다.
- 그래서 원하는 요청이 완료되었는지 지속적으로 확인해야한다.(polling)
- 최종적으로 원하는 데이터가 다 들어왔는지 파악해야 한다. 


####### 내 용어로 정리!
Async : 작업을 요청하고 바로 유저 프로세스의 작업을 처리한다. 이후에 I/O 작업이 끝나게 되면, Callback을 통해서 완료된 데이터를 가져와서 처리한다. 


Non-block: 마찬가지로 작업을 요청하고 바로 유저 프로세스의 작업을 처리한다. 그리고 System Call이 return하는 결과를 계속해서 확인하여 원하는 데이터 인지 체크해야 한다. 

Sync와 Async는 I/O 완료 이벤트 통지하는 방법이다.
- 동기 : 시스템 콜이 완료되기를 기다린다. 
- 비동기 : 시스템콜을 기다리지 않는다. 

- Block : 운영체제 대기큐에 들어간다
- Non-block : 운영체제 대기큐에 들어가지 않는다. 그래서 실행 여부와 상관없이 바로 응답을 보낸다. 
	:: 정상 데이터가 올 때 까지 계속 시스템콜을 하며 Context Switching이 일어나게 된다. 






- http://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/

* 관련 내용 정리 
- http://sjh836.tistory.com/109
- http://brainbackdoor.tistory.com/26

